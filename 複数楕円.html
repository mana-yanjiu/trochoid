<html>
  <head>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
        padding: 0;
        overscroll-behavior-x: none;
        overscroll-behavior-y: none;
      }
      #contents {
        display: flex;
        margin: 10px;
      }
      #form {
        margin-right: 10px;
        width: 300px;
        padding: 5px 5px 0 5px;
        border: solid 1px #aaaaaa;
        box-sizing: border-box;
        font-size: 12px;
      }
      #form .row {
        list-style: none;
        margin: 0 0 5px 0;
        padding: 5px;
        background-color: #eeeeff;
      }
      #form .row .operator {
        display: flex;
        align-items: center;
      }
      #form .row .input {
        margin-right: 5px;
        width: 50px;
      }
      #form .submit-row {
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 0 5px 0;
        padding-top: 5px;
        border-top: solid 1px #dddddd;
      }
      #form .submit-row button {
        margin: 0 5px;
      }
      .meter {
        position: relative;
        height: 24px;
        margin-top: 5px;
      }
      .meter::before {
        content: "";
        position: absolute;
        display: block;
        width: 100%;
        height: 1px;
        top: 50%;
        border-top: solid 1px #aaaaaa;
      }
      .meter-handle {
        position: absolute;
        top: 0;
        width: 10px;
        height: calc(100% - 2px);
        border: solid 1px #888888;
        background-color: #ffffff;
      }
      #display-wrapper {
        position: relative;
        border: solid 1px #aaaaaa;
      }
      #display,
      #auxiliary-line,
      #focal-length-screen,
      #focal-length-operator {
        position: absolute;
        top: 0;
        left: 0;
      }
      #focal-length-wrapper {
        display: grid;
        grid-template-columns: 35% 1fr;
        grid-template-rows: auto 1fr;
        margin: 0;
        padding: 0;
      }
      #focal-length-wrapper .title {
        grid-column: 1;
      }
      #focal-length-announcer-wrapper {
        grid-column: 1;
        grid-row: 2;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: flex-start;
        line-height: 24px;
        padding-left: 5px;
      }
      #focal-length-operator-wrapper {
        grid-column: 2;
        grid-row: 1 / 3;
        position: relative;
        width: 120px;
        height: 120px;
      }
      #focal-length-announcer-wrapper div {
        white-space: nowrap;
      }
      #color-base-wrapper,
      #color-balance-wrapper {
        position: relative;
        margin: 5px auto 0;
        width: 270px;
      }
      #color-base-wrapper {
        height: 20px;
      }
      #color-balance-wrapper {
        height: 70px;
      }
      #color-base-wrapper canvas,
      #color-balance-wrapper canvas {
        position: absolute;
      }
      #tangent-type-wrapper {
        display: flex;
      }
      #counter {
        position: relative;
        height: 30px;
        padding: 0;
        border-right: solid 1px #aaaaaa;
        border-bottom: solid 1px #aaaaaa;
        border-left: solid 1px #aaaaaa;
      }
      #announcer {
        position: absolute;
        box-sizing: border-box;
        width: 100%;
        height: 30px;
        line-height: 30px;
        padding: 0 5px;
        text-align: right;
      }
      #gauge {
        position: absolute;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="contents">
      <form id="form">
        <div class="row">
          <div class="operator">
            <span class="title">単位円</span>：<input type="text" class="input" id="standing-circle-circumference" />
            <button id="standing-circle-circumference-submit">指定</button>
          </div>
          <div class="meter" id="standing-circle-circumference-meter">
            <div class="meter-handle" id="standing-circle-circumference-meter-handle"></div>
          </div>
        </div>
        <div class="row">
          <div class="operator">
            <span class="title">回転円1</span>：<input type="text" class="input" id="回転円1" />
            <button id="回転円1-submit">指定</button>
          </div>
          <div class="meter" id="回転円1-meter">
            <div class="meter-handle" id="回転円1-meter-handle"></div>
          </div>
        </div>
        <div class="row">
          <div class="operator">
            <span class="title">扁平率1</span>：<input type="text" class="input" id="扁平率1" />
            <button id="扁平率1-submit">指定</button>
          </div>
          <div class="meter" id="扁平率1-meter">
            <div class="meter-handle" id="扁平率1-meter-handle"></div>
          </div>
        </div>
        <div class="row">
          <div class="operator">
            <span class="title">回転円2</span>：<input type="text" class="input" id="回転円2" />
            <button id="回転円2-submit">指定</button>
          </div>
          <div class="meter" id="回転円2-meter">
            <div class="meter-handle" id="回転円2-meter-handle"></div>
          </div>
        </div>
        <div class="row">
          <div class="operator">
            <span class="title">扁平率2</span>：<input type="text" class="input" id="扁平率2" />
            <button id="扁平率2-submit">指定</button>
          </div>
          <div class="meter" id="扁平率2-meter">
            <div class="meter-handle" id="扁平率2-meter-handle"></div>
          </div>
        </div>
        <div class="row">
          <div id="focal-length-wrapper">
            <div class="title">描画点：</div>
            <div id="focal-length-announcer-wrapper">
              <div>長さ：<span id="focal-length-announcer-P"></span>%</div>
              <div>角度：<span id="focal-length-announcer-T"></span>°</div>
            </div>
            <div id="focal-length-operator-wrapper">
              <canvas id="focal-length-screen" width="120" height="120"></canvas>
              <canvas id="focal-length-operator" width="120" height="120"></canvas>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="operator">
            <span class="title">線の色</span>：<span id="color-announcer"></span>
          </div>
          <div id="color-base-wrapper">
            <canvas id="color-base-screen" width="270" height="20"></canvas>
            <canvas id="color-base-operator" width="270" height="20"></canvas>
          </div>
          <div id="color-balance-wrapper">
            <canvas id="color-balance-screen" width="270" height="70"></canvas>
            <canvas id="color-balance-operator" width="270" height="70"></canvas>
          </div>
        </div>
        <div class="row" id="tangent-type-wrapper">
          <input type="radio" name="tangent-type" id="tangent-type-I" checked /><label for="tangent-type-I">内接</label>
          <input type="radio" name="tangent-type" id="tangent-type-O" /><label for="tangent-type-O">外接</label>
        </div>
        <div class="submit-row">
          <button id="execute">描画開始</button>
          <button id="pause">停止</button>
          <button id="delete">削除</button>
        </div>
      </form>
      <div id="display-counter-wrapper">
        <div id="display-wrapper">
          <canvas id="auxiliary"></canvas>
          <canvas id="display"></canvas>
        </div>
        <div id="counter">
          <canvas id="gauge"></canvas>
          <div id="announcer"></div>
        </div>
      </div>
    </div>
    <script>
      const 単位円径 = 200;
      const 単位円周 = 600;
      const 楕円解像度 = 240;
      const 楕円解像単位角度 = Math.PI / 2 / 楕円解像度;
      const 表示枠幅 = 500;
      const 表示径 = 表示枠幅 / 2;
      const gaugeHeight = 30;

      const 表示枠実体 = document.getElementById('display-wrapper');
      const display = document.getElementById('display');
      const auxiliary = document.getElementById('auxiliary');
      const 焦点距離Screen = document.getElementById('focal-length-screen');
      const 焦点距離Operator = document.getElementById('focal-length-operator');
      const 焦点距離AnnouncerT = document.getElementById('focal-length-announcer-T');
      const 焦点距離AnnouncerP = document.getElementById('focal-length-announcer-P');
      const colorBaseScreen = document.getElementById('color-base-screen');
      const colorBaseOperator = document.getElementById('color-base-operator');
      const colorBalanceScreen = document.getElementById('color-balance-screen');
      const colorBalanceOperator = document.getElementById('color-balance-operator');
      const colorAnnouncer = document.getElementById('color-announcer');
      const executeButton = document.getElementById('execute');
      const pauseButton = document.getElementById('pause');
      const deleteButton = document.getElementById('delete');
      const counterAnnouncer = document.getElementById('announcer');
      const counterGauge = document.getElementById('gauge');
      const form = document.getElementById('form');
      const tangentTypeInputI = document.getElementById('tangent-type-I');
      const tangentTypeInputO = document.getElementById('tangent-type-O');

      const displayContext = display.getContext('2d');
      const auxiliaryContext = auxiliary.getContext('2d');
      const 焦点距離ScreenContext = 焦点距離Screen.getContext('2d');
      const 焦点距離OperatorContext = 焦点距離Operator.getContext('2d');
      const counterGaugeContext = counterGauge.getContext('2d');
      const colorBaseScreenContext = colorBaseScreen.getContext('2d');
      const colorBaseOperatorContext = colorBaseOperator.getContext('2d');
      const colorBalanceScreenContext = colorBalanceScreen.getContext('2d');
      const colorBalanceOperatorContext = colorBalanceOperator.getContext('2d');

      const meterElements = ['standing-circle-circumference', '回転円1', '回転円2', '扁平率1', '扁平率2'].reduce((elements, meterType) => ({
        ...elements, [meterType]: {
          input: document.getElementById(`${meterType}`),
          meter: document.getElementById(`${meterType}-meter`),
          handle: document.getElementById(`${meterType}-meter-handle`),
          submit: document.getElementById(`${meterType}-submit`),
        },
      }), {});
      表示枠実体.style.width = `${表示枠幅}px`;
      表示枠実体.style.height = `${表示枠幅}px`;
      counterGauge.style.width = `${表示枠幅}px`;
      counter.style.width = `${表示枠幅}px`;
      display.setAttribute('width', 表示枠幅);
      display.setAttribute('height', 表示枠幅);
      auxiliary.setAttribute('width', 表示枠幅);
      auxiliary.setAttribute('height', 表示枠幅);
      counterGauge.setAttribute('width', 表示枠幅);
      counterGauge.setAttribute('height', gaugeHeight);
      counterGaugeContext.fillStyle = '#66cc66';
      焦点距離ScreenContext.strokeStyle = '#880000';
      焦点距離ScreenContext.beginPath();
      焦点距離ScreenContext.arc(60, 60, 25, 0, Math.PI * 2);
      焦点距離ScreenContext.closePath();
      焦点距離ScreenContext.stroke();
      焦点距離ScreenContext.strokeStyle = '#dd7777';
      焦点距離ScreenContext.beginPath();
      焦点距離ScreenContext.arc(60, 60, 50, 0, Math.PI * 2);
      焦点距離ScreenContext.closePath();
      焦点距離ScreenContext.stroke();
      焦点距離OperatorContext.strokeStyle = '#aa0000';
      colorBaseOperatorContext.strokeStyle = '#ffffff';
      colorBaseOperatorContext.fillStyle = '#ffffff';
      colorBaseOperatorContext.lineWidth = 2;
      colorBalanceOperatorContext.strokeStyle = '#ffffff';
      colorBalanceOperatorContext.lineWidth = 2;

      const 回転円 = [
        { 周: 240, 近似周群: [], 単位長径: 1, 単位短径: 1, 長径: 1, 短径: 1, 偏平率: 0 },
        { 周: 150, 近似周群: [], 単位長径: 1, 単位短径: 1, 長径: 1, 短径: 1, 偏平率: 0 },
      ];
      const 描画制御 = {
        動作: null,
        動作指示: false,
        前回座標: [0, 0],
        進捗: 0,
      };
      let 静止円周 = 350;
      let 静止円径 = 単位円径 * 静止円周 / 単位円周;
      let 焦点距離率 = 0.8;
      let 焦点距離 = 0;
      let 焦点主観角度 = 120 / 180 * Math.PI;
      let 焦点客観角度 = 0;
      let tangentType = 'I';
      let meterHandleDiffX = 0;
      let meterSwitch = false;
      let animationSwitch = false;
      let animation = null;
      let startedSwitch = false;
      let latestX = 0;
      let latestY = 0;
      let timerMultiple = 1;
      let strokeColorBase = 0.07;
      let strokeColorBalance = 0.8;
      let strokeColorSaturation = 0.9;
      let strokeColor = '#000000';

      const 楕円近似弧群定義 = () => {
        回転円.forEach((設定) => {
          const 近似周係数1 = 2 - 設定.偏平率;
          const 近似周係数2 = 3 * Math.pow(設定.偏平率 / 近似周係数1, 2);
          const 近似周係数3 = Math.PI * 近似周係数1 * (1 + 近似周係数2 / (10 + Math.pow(4 - 近似周係数2, 1 / 2)));
          設定.単位長径 = 設定.周 / 近似周係数3;
          設定.単位短径 = 設定.単位長径 * (1 - 設定.偏平率);
          設定.長径 = 設定.単位長径 * 単位円径 * Math.PI * 2 / 単位円周;
          設定.短径 = 設定.単位短径 * 単位円径 * Math.PI * 2 / 単位円周;
          設定.近似周群 = Array(楕円解像度).fill(null).reduce((群, _, 段階) => {
            const WY = 設定.単位長径 * Math.cos(楕円解像単位角度 * (段階 + 1));
            const WX = 設定.単位短径 * Math.sin(楕円解像単位角度 * (段階 + 1));
            const WA = Math.pow(Math.pow(群[段階].WY - WY, 2) + Math.pow(WX - 群[段階].WX, 2), 1 / 2);

            return [...群, { WY, WX, WA }];
          }, [{ WY: 設定.単位長径, WX: 0, WA: 0 }]);
        });

        const DX = Math.sin(焦点主観角度) * 回転円[0].短径 * 焦点距離率;
        const DY = Math.cos(焦点主観角度) * 回転円[0].長径 * 焦点距離率;
        焦点距離 = Math.pow(DX * DX + DY * DY, 1 / 2);
        焦点客観角度 = Math.acos(DY / 焦点距離) * (DX >= 0 ? 1 : -1);
      };

      const 座標計算 = () => {
        const 環境角度 = Math.PI * 2 / 静止円周 * 描画制御.進捗;
        const 環境座標X = Math.sin(環境角度) * 静止円径;
        const 環境座標Y = Math.cos(環境角度) * 静止円径;
        const 環境 = { 角度: 環境角度, 座標: [環境座標X, 環境座標Y] };
        const 座標群 = [];

        回転円.forEach((設定, 設定番号) => {
          const 進行長 = 描画制御.進捗 % 設定.周;
          const 段階 = Math.floor(進行長 / (設定.周 / 4));
          const 段階進行長 = 進行長 % (設定.周 / 4);

          let LP = 0;
          let WY = 0;

          for (let j = 1; j <= 楕円解像度; j ++) {
            const ELP = !(段階 % 2) ? 設定.近似周群[j] : 設定.近似周群[楕円解像度 - j];

            if (LP + ELP.WA > 段階進行長) {
              const 余剰係数 = (段階進行長 - LP) / ELP.WA;
              WY = !(段階 % 2)
                ? 設定.近似周群[j - 1].WY - (設定.近似周群[j - 1].WY - ELP.WY) * 余剰係数
                : ELP.WY - (ELP.WY - (j < 楕円解像度 ? 設定.近似周群[楕円解像度 - j + 1].WY : 0)) * (1 - 余剰係数);

              break;
            }

            LP += ELP.WA;
            WY = ELP.WY;
          }

          WY *= 単位円径 / 単位円周 * Math.PI * 2;
          WY = Math.min(WY, 設定.長径);
          WY *= [1, 2].includes(段階) ? -1 : 1;

          const RL2 = Math.pow(設定.長径, 2);
          const RS2 = Math.pow(設定.短径, 2);
          const WX = Math.pow((1 - WY * WY / RL2) * RS2, 1 / 2) * ([2, 3].includes(段階) ? -1 : 1) * (設定番号 % 2 ? -1 : 1);
          const 接点距離 = Math.pow(WX * WX + WY * WY, 1 / 2);
          const 接点角度 = Math.acos(WY / 接点距離) * (WX >= 0 ? 1 : -1);
          const 接線X軸交点座標 = WX === 0 ? Infinity : (RS2 / WX);
          const 接線Y軸交点座標 = WY === 0 ? Infinity : (RL2 / WY);
          const 接線長 = Math.pow(Math.pow(接線X軸交点座標, 2) + Math.pow(接線Y軸交点座標, 2), 1 / 2);
          const 接線角度 =
            接線X軸交点座標 === Infinity ? (WY >= 0 ? 0 : Math.PI) :
            接線Y軸交点座標 === Infinity ? (Math.PI / (WX >= 0 ? -2 : 2)) :
            (接線X軸交点座標 >= 0 && 接線Y軸交点座標 >= 0) ? Math.acos(接線X軸交点座標 / 接線長) :
            (接線X軸交点座標 >= 0 && 接線Y軸交点座標 < 0) ? Math.acos(接線X軸交点座標 * -1 / 接線長) :
            (接線X軸交点座標 < 0 && 接線Y軸交点座標 < 0) ? (Math.acos(接線X軸交点座標 / 接線長) * -1) : (Math.acos(接線X軸交点座標 * -1 / 接線長) * -1);

          座標群.push({
            X: 環境.座標[0] - Math.sin(接点角度 - 接線角度 + 環境.角度) * 接点距離,
            Y: 環境.座標[1] - Math.cos(接点角度 - 接線角度 + 環境.角度) * 接点距離,
            T: 環境.角度 - 接線角度,
          });

          環境.座標[0] = 座標群[設定番号].X - Math.sin(環境.角度 - 接線角度 + Math.PI - 接点角度) * 接点距離;
          環境.座標[1] = 座標群[設定番号].Y - Math.cos(環境.角度 - 接線角度 + Math.PI - 接点角度) * 接点距離;
          環境.角度 = 環境.角度 + Math.PI - (接線角度 - Math.PI / 2) * 2;

          接線角度 - Math.PI / 2
        });

        return 座標群;
      };

      const output = () => {
        const 角度 = Math.PI * 2 / 静止円周 * 描画制御.進捗;
        const 座標群 = 座標計算();

        auxiliaryContext.clearRect(0, 0, 表示枠幅, 表示枠幅);
        auxiliaryContext.setTransform(1, 0, 0, 1, 0, 0);
        auxiliaryContext.strokeStyle = '#cccccc';
        auxiliaryContext.beginPath();
        auxiliaryContext.arc(表示径 - 0.5, 表示径 - 0.5, 静止円径, 0, Math.PI * 2);
        auxiliaryContext.closePath();
        auxiliaryContext.stroke();
        auxiliaryContext.strokeStyle = '#c0c0ee';
        回転円.forEach((設定, 設定番号) => {
          const { X: CX, Y: CY, T: CT } = 座標群[設定番号];
          const DX = CX + Math.sin(CT + 焦点客観角度) * 焦点距離;
          const DY = CY + Math.cos(CT + 焦点客観角度) * 焦点距離;
          const EXB = 設定.単位短径 * 単位円径 * Math.PI * 2 / 単位円周;
          const EYB = 設定.単位長径 * 単位円径 * Math.PI * 2 / 単位円周;
          auxiliaryContext.beginPath();
          auxiliaryContext.ellipse(表示径 - CX, 表示径 + CY, 設定.短径, 設定.長径, CT, 0, Math.PI * 2);
          auxiliaryContext.closePath();
          auxiliaryContext.stroke();
          Array(8).fill(null).forEach((_, i) => {
            const EX = Math.sin(Math.PI * 2 / 8 * (i + 0.5)) * EXB;
            const EY = Math.cos(Math.PI * 2 / 8 * (i + 0.5)) * EYB;
            const ER = Math.pow(EX * EX + EY * EY, 1 / 2);
            const ET = Math.acos(EY / ER) * (EX >= 0 ? 1 : -1);
            const EL = ER - EXB * 0.3;
            auxiliaryContext.beginPath();
            auxiliaryContext.arc(表示径 - CX - Math.sin(CT + ET) * EL, 表示径 + CY + Math.cos(CT + ET) * EL, EXB * 0.1, 0, Math.PI * 2);
            auxiliaryContext.closePath();
            auxiliaryContext.stroke();
          });
          if (設定番号 === 回転円.length - 1) {
            auxiliaryContext.beginPath();
            auxiliaryContext.moveTo(表示径 - CX, 表示径 + CY);
            auxiliaryContext.lineTo(表示径 - DX, 表示径 + DY);
            auxiliaryContext.closePath();
            auxiliaryContext.stroke();
            if (描画制御.進捗 > 0) {
              displayContext.strokeStyle = strokeColor;
              displayContext.beginPath();
              displayContext.moveTo(表示径 - latestX, 表示径 + latestY);
              displayContext.lineTo(表示径 - DX, 表示径 + DY);
              displayContext.closePath();
              displayContext.stroke();
            }

            latestX = DX;
            latestY = DY;
          }
        });
        auxiliaryContext.strokeStyle = '#aaaaff';
        auxiliaryContext.beginPath();
        auxiliaryContext.moveTo(表示径, 表示径);
        auxiliaryContext.lineTo(表示径 - 静止円径 * Math.sin(角度), 表示径 + 静止円径 * Math.cos(角度));
        auxiliaryContext.closePath();
        auxiliaryContext.stroke();
        auxiliaryContext.strokeStyle = '#ccccff';
      };

      const animate = () => {
        output();
        描画制御.進捗 ++;
        counterGaugeContext.setTransform(1, 0, 0, 1, 0, 0);
        counterGaugeContext.clearRect(0, 0, 表示枠幅, gaugeHeight);
        counterGaugeContext.fillRect(0, 0, 表示枠幅 * 描画制御.進捗 / timerMultiple, gaugeHeight);
        counterAnnouncer.innerText = `${描画制御.進捗} / ${timerMultiple}`;
        if (描画制御.進捗 < timerMultiple) {
          if (animationSwitch) {
            animation = setTimeout(animate, 5);
          }
        } else {
          endExecution();
        }
      };

      const startAnimation = () => {
        if (animation) clearInterval(animation);
        animationSwitch = true;
        animate();
      };

      const stopAnimation = () => {
        if (animation) clearTimeout(animation);
        animationSwitch = false;
      };

      const getMeterParams = (meterType) => {
        const meterRect = meterElements[meterType].meter.getBoundingClientRect();
        const meterHandleRect = meterElements[meterType].handle.getBoundingClientRect();

        return {
          left: meterRect.left + meterHandleRect.width / 2,
          right: meterRect.left + meterRect.width - meterHandleRect.width / 2,
        };
      };

      const setMeterPosition = (meterType, percentage) => {
        if (animationSwitch) return;

        const { left, right } = getMeterParams(meterType);
        meterElements[meterType].handle.style.left = `${Math.floor((right - left) * percentage)}px`;
      };

      const setMeterSwitch = (operate, clientX) => {
        if (animationSwitch && operate) return;
        meterSwitch = operate;
        if (operate === false) return;
        const meterHandleRect = meterElements[operate].handle.getBoundingClientRect();
        if (clientX >= meterHandleRect.left && clientX <= meterHandleRect.left + meterHandleRect.width) {
          meterHandleDiffX = clientX - (meterHandleRect.left + meterHandleRect.width / 2);
        } else {
          meterHandleDiffX = 0;
          setMeterLength(operate, clientX);
        }
      };

      const setMeterPercentage = (meterType, percentage) => {
        if (animationSwitch) return;
        if (percentage < 0) percentage = 0;
        if (percentage > 1) percentage = 1;
        percentage = Math.floor(percentage * 100) / 100;
        setMeterPosition(meterType, percentage);
        switch (meterType) {
          case 'standing-circle-circumference':
            静止円周 = Math.floor(単位円周 / 10 + percentage * (単位円周 - 単位円周 / 10));
            静止円径 = 単位円径 * 静止円周 / 単位円周;
            settimerMultiple();
            meterElements[meterType].input.value = 静止円周;
            楕円近似弧群定義();
            break;
          case '回転円1':
            回転円[0].周 = Math.floor(単位円周 / 10 + percentage * (単位円周 - 単位円周 / 10));
            rolingCircleRadius = 単位円径 * 回転円[0].周 / 単位円周;
            settimerMultiple();
            meterElements[meterType].input.value = 回転円[0].周;
            楕円近似弧群定義();
            break;
          case '回転円2':
            回転円[1].周 = Math.floor(単位円周 / 10 + percentage * (単位円周 - 単位円周 / 10));
            rolingCircleRadius = 単位円径 * 回転円[1].周 / 単位円周;
            settimerMultiple();
            meterElements[meterType].input.value = 回転円[1].周;
            楕円近似弧群定義();
            break;
          case '扁平率1':
            回転円[0].偏平率 = Math.floor(90 * percentage) / 100;
            settimerMultiple();
            meterElements[meterType].input.value = 回転円[0].偏平率 * 100;
            楕円近似弧群定義();
            break;
          case '扁平率2':
            回転円[1].偏平率 = Math.floor(90 * percentage) / 100;
            settimerMultiple();
            meterElements[meterType].input.value = 回転円[1].偏平率 * 100;
            楕円近似弧群定義();
            break;
          default:
        }
        output();
      };

      const setMeterLength = (meterType, clientX) => {
        if (animationSwitch) return;
        const { left, right } = getMeterParams(meterType);
        const percentage = (clientX - meterHandleDiffX - left) / (right - left);
        setMeterPercentage(meterType, percentage);
      };

      const submitMeter = (meterType) => {
        if (animationSwitch) return;
        const inputValue = parseInt(meterElements[meterType].input.value);
        switch (meterType) {
          case 'standing-circle-circumference':
            静止円周 = inputValue;
            if (静止円周 < 単位円周 / 10) 静止円周 = 単位円周 / 10;
            if (静止円周 > 単位円周) 静止円周 = 単位円周;
            setMeterPosition(meterType, (静止円周 - 単位円周 / 10) / (単位円周 - 単位円周 / 10));
            静止円径 = 単位円径 * 静止円周 / 単位円周;
            meterElements[meterType].input.value = 静止円周;
            楕円近似弧群定義();
            settimerMultiple();
            output();
            break;
          case '回転円1':
            回転円[0].周 = inputValue;
            if (回転円[0].周 < 単位円周 / 10) 回転円[0].周 = 単位円周 / 10;
            if (回転円[0].周 > 単位円周) 回転円[0].周 = 単位円周;
            setMeterPosition(meterType, (回転円[0].周 - 単位円周 / 10) / (単位円周 - 単位円周 / 10));
            meterElements[meterType].input.value = 回転円[0].周;
            楕円近似弧群定義();
            settimerMultiple();
            output();
            break;
          case '回転円2':
            回転円[1].周 = inputValue;
            if (回転円[1].周 < 単位円周 / 10) 回転円[1].周 = 単位円周 / 10;
            if (回転円[1].周 > 単位円周) 回転円[1].周 = 単位円周;
            setMeterPosition(meterType, (回転円[1].周 - 単位円周 / 10) / (単位円周 - 単位円周 / 10));
            meterElements[meterType].input.value = 回転円[1].周;
            楕円近似弧群定義();
            settimerMultiple();
            output();
            break;
          case '扁平率1':
            回転円[0].偏平率 = inputValue / 100;
            if (回転円[0].偏平率 < 0) 回転円[0].偏平率 = 0;
            if (回転円[0].偏平率 > 0.9) 回転円[0].偏平率 = 0.9;
            setMeterPosition(meterType, 回転円[0].偏平率 / 0.9);
            meterElements[meterType].input.value = 回転円[0].偏平率 * 100;
            楕円近似弧群定義();
            settimerMultiple();
            output();
            break;
          case '扁平率2':
            回転円[1].偏平率 = inputValue / 100;
            if (回転円[1].偏平率 < 0) 回転円[1].偏平率 = 0;
            if (回転円[1].偏平率 > 0.9) 回転円[1].偏平率 = 0.9;
            setMeterPosition(meterType, 回転円[1].偏平率 / 0.9);
            meterElements[meterType].input.value = 回転円[1].偏平率 * 100;
            楕円近似弧群定義();
            settimerMultiple();
            output();
            break;
          default:
        }
      };

      const set焦点距離 = (event, operate) => {
        const operatorHandleRect = 焦点距離Operator.getBoundingClientRect();
        const client = getClientPosition(event);
        const X = 60 - client.X + operatorHandleRect.left;
        const Y = 60 - client.Y + operatorHandleRect.top;
        const R = Math.pow(X * X + Y * Y, 1 / 2);
        if (R > 50 && operate !== 'move') return;
        焦点主観角度 = Math.acos(Y * -1 / R) * (X >= 0 ? 1 : -1);
        焦点距離率 = Math.min(R / 25, 2);

        display焦点距離();
        楕円近似弧群定義();
        output();
      };

      const display焦点距離 = () => {
        const X = Math.sin(焦点主観角度) * 焦点距離率 * 25;
        const Y = Math.cos(焦点主観角度) * 焦点距離率 * -25;
        焦点距離OperatorContext.clearRect(0, 0, 120, 120);
        焦点距離OperatorContext.setTransform(1, 0, 0, 1, 0, 0);
        焦点距離OperatorContext.beginPath();
        焦点距離OperatorContext.arc(60 - X, 60 - Y, 5, 0, Math.PI * 2);
        焦点距離OperatorContext.closePath();
        焦点距離OperatorContext.fill();
        焦点距離AnnouncerT.innerText = Math.round(焦点主観角度 / Math.PI * 180);
        焦点距離AnnouncerP.innerText = Math.round(焦点距離率 * 100);
      };

      const initColor = () => {
        const colors = [
          '#ff0000',
          '#ff00ff',
          '#0000ff',
          '#00ffff',
          '#00ff00',
          '#ffff00',
        ];
        colors.forEach((color, i) => {
          const XS = 45 * i;
          const XE = 45 * (i + 1);
          const palet = colorBaseScreenContext.createLinearGradient(XS, 0, XE, 0);
          palet.addColorStop(0.0, color);
          palet.addColorStop(1.0, colors[(i + 1) % 6]);
          colorBaseScreenContext.fillStyle = palet;
          colorBaseScreenContext.beginPath();
          colorBaseScreenContext.rect(XS, 0, XE, 20);
          colorBaseScreenContext.closePath();
          colorBaseScreenContext.fill();
        });

        setColor();
      };

      const setColorBase = (event, operate) => {
        const operatorHandleRect = colorBaseOperator.getBoundingClientRect();
        const client = getClientPosition(event);
        const X = client.X - operatorHandleRect.left;
        let P = X / operatorHandleRect.width;
        if ((P < 0 || P > 1) && operate !== 'move') return;
        if (P < 0) P = 0;
        if (P > 1) P = 1;

        strokeColorBase = P;

        setColor();
        displayColorBase();
      };

      const setColorBalance = (event, operate) => {
        const operatorHandleRect = colorBalanceOperator.getBoundingClientRect();
        const client = getClientPosition(event);
        const X = client.X - operatorHandleRect.left;
        const Y = client.Y - operatorHandleRect.top;
        let PX = X / operatorHandleRect.width;
        let PY = Y / operatorHandleRect.height;
        if ((PX < 0 || PX > 1 || PY < 0 || PY > 1) && operate !== 'move') return;
        if (PX < 0) PX = 0;
        if (PX > 1) PX = 1;
        if (PY < 0) PY = 0;
        if (PY > 1) PY = 1;

        strokeColorSaturation = PX;
        strokeColorBalance = 1 - PY;

        setColor();
        displayColorBalance();
      };

      const setColor = () => {
        let [R, G, B] = getColorElements();
        R += (1 - R) * (1 - strokeColorSaturation);
        G += (1 - G) * (1 - strokeColorSaturation);
        B += (1 - B) * (1 - strokeColorSaturation);
        R = Math.floor(R * strokeColorBalance * 255);
        G = Math.floor(G * strokeColorBalance * 255);
        B = Math.floor(B * strokeColorBalance * 255);
        R = (R < 16 ? '0' : '') + R.toString(16);
        G = (G < 16 ? '0' : '') + G.toString(16);
        B = (B < 16 ? '0' : '') + B.toString(16);

        strokeColor = `#${R}${G}${B}`;
        colorAnnouncer.innerText = strokeColor;
      };

      const displayColorBase = () => {
        colorBaseOperatorContext.clearRect(0, 0, 270, 20);
        colorBaseOperatorContext.setTransform(1, 0, 0, 1, 0, 0);
        colorBaseOperatorContext.beginPath();
        colorBaseOperatorContext.moveTo(270 * strokeColorBase, 0);
        colorBaseOperatorContext.lineTo(270 * strokeColorBase, 20);
        colorBaseOperatorContext.closePath();
        colorBaseOperatorContext.stroke();
        colorBaseOperatorContext.beginPath();
        colorBaseOperatorContext.moveTo(270 * strokeColorBase - 5, 8);
        colorBaseOperatorContext.lineTo(270 * strokeColorBase - 5, 12);
        colorBaseOperatorContext.lineTo(270 * strokeColorBase - 2, 10);
        colorBaseOperatorContext.closePath();
        colorBaseOperatorContext.fill();
        colorBaseOperatorContext.beginPath();
        colorBaseOperatorContext.moveTo(270 * strokeColorBase + 5, 8);
        colorBaseOperatorContext.lineTo(270 * strokeColorBase + 5, 12);
        colorBaseOperatorContext.lineTo(270 * strokeColorBase + 2, 10);
        colorBaseOperatorContext.closePath();
        colorBaseOperatorContext.fill();

        const [R, G, B] = getColorElements();

        const paletC = colorBalanceScreenContext.createLinearGradient(0, 0, 270, 0);
        paletC.addColorStop(0.0, '#ffffff');
        paletC.addColorStop(1.0, `rgb(${Math.floor(R * 255)}, ${Math.floor(G * 255)}, ${Math.floor(B * 255)})`);
        colorBalanceScreenContext.clearRect(0, 0, 270, 70);
        colorBalanceScreenContext.setTransform(1, 0, 0, 1, 0, 0);
        colorBalanceScreenContext.fillStyle = paletC;
        colorBalanceScreenContext.beginPath();
        colorBalanceScreenContext.rect(0, 0, 270, 70);
        colorBalanceScreenContext.closePath();
        colorBalanceScreenContext.fill();
        const paletT = colorBalanceScreenContext.createLinearGradient(0, 0, 0, 70);
        paletT.addColorStop(0.0, '#00000000');
        paletT.addColorStop(1.0, '#000000ff');
        colorBalanceScreenContext.fillStyle = paletT;
        colorBalanceScreenContext.beginPath();
        colorBalanceScreenContext.rect(0, 0, 270, 70);
        colorBalanceScreenContext.closePath();
        colorBalanceScreenContext.fill();
      };

      const displayColorBalance = () => {
        colorBalanceOperatorContext.clearRect(0, 0, 270, 70);
        colorBalanceOperatorContext.setTransform(1, 0, 0, 1, 0, 0);
        colorBalanceOperatorContext.beginPath();
        colorBalanceOperatorContext.arc(270 * strokeColorSaturation, 70 * (1 - strokeColorBalance), 7, 0, Math.PI * 2);
        colorBalanceOperatorContext.closePath();
        colorBalanceOperatorContext.stroke();
      };

      const getColorElements = () => {
        const PB = strokeColorBase * 6 - Math.floor(strokeColorBase * 6);

        switch (Math.floor(strokeColorBase * 6)) {
          case 0:
            return [1, 0, PB];
          case 1:
            return [1 - PB, 0, 1];
          case 2:
            return [0, PB, 1];
          case 3:
            return [0, 1, 1 - PB];
          case 4:
            return [PB, 1, 0];
          default:
            return [1, 1 - PB, 0];
        }
      };

      const getClientPosition = (event) => ({
        X: event.clientX !== undefined ? event.clientX : event.changedTouches[0].clientX,
        Y: event.clientY !== undefined ? event.clientY : event.changedTouches[0].clientY,
      });

      const 素因数分解 = (分子, 分母, 指数 = 0) => 分子 % 分母 ? [分子, 指数] : 素因数分解(分子 / 分母, 分母, 指数 + 1);

      const settimerMultiple = () => {
        const 公倍数群 = [静止円周, ...回転円.map(({ 周 }) => 周)].reduce((群, 周) => {
          try {
            Array(周 - 1).fill(null).reduce((分子, _, 分母係数) => {
              const [残数, 指数] = 素因数分解(分子, 分母係数 + 2);
              if (指数) {
                群[分母係数 + 2] = Math.max(群[分母係数 + 2] ?? 0, 指数);
              }
              if ((分母係数 + 2) * 2 > 残数) {
                if (残数 > 1) {
                  群[残数] = Math.max(群[残数] ?? 0, 1);
                }
                throw null;
              }

              return 残数;
            }, 周);
          } catch (_) {
          }

          return 群;
        }, {});
        timerMultiple = Object.keys(公倍数群).reduce((値, 係数) => 値 * Math.pow(係数, 公倍数群[係数]), 1);
        if (
          !((timerMultiple / 2) % 静止円周) &&
          !((timerMultiple / 2) % 回転円[1].周) &&
          ((timerMultiple / 2) % 回転円[0].周 === 回転円[0].周 / 2)
        ) {
          timerMultiple /= 2;
        }
        counterGaugeContext.clearRect(0, 0, 表示枠幅, gaugeHeight);
        counterAnnouncer.innerText = `0 / ${timerMultiple}`;
      }

      const startExecution = () => {
        startedSwitch = true;
        startAnimation();
        Object.keys(meterElements).forEach((meterKey) => {
          meterElements[meterKey].input.disabled = true;
          meterElements[meterKey].submit.disabled = true;
        });
        tangentTypeInputI.disabled = true;
        tangentTypeInputO.disabled = true;
        executeButton.disabled = true;
        pauseButton.innerText = '停止';
        pauseButton.disabled = false;
        deleteButton.disabled = false;
        counterGaugeContext.clearRect(0, 0, 表示枠幅, gaugeHeight);
        counterAnnouncer.innerText = `0 / ${timerMultiple}`;
      };

      const endExecution = () => {
        startedSwitch = false;
        stopAnimation();
        auxiliaryContext.setTransform(1, 0, 0, 1, 0, 0);
        auxiliaryContext.clearRect(0, 0, 表示枠幅, 表示枠幅);
        描画制御.進捗 = 0;
        Object.keys(meterElements).forEach((meterKey) => {
          meterElements[meterKey].input.disabled = false;
          meterElements[meterKey].submit.disabled = false;
        });
        tangentTypeInputI.disabled = false;
        tangentTypeInputO.disabled = false;
        executeButton.disabled = false;
        pauseButton.disabled = true;
      };

      const pause = () => {
        if (!animationSwitch) {
          startAnimation();
          pauseButton.innerText = '停止';
        } else {
          stopAnimation();
          pauseButton.innerText = '再開';
        }
      };

      const deleteExecution = () => {
        endExecution();
        displayContext.setTransform(1, 0, 0, 1, 0, 0);
        displayContext.clearRect(0, 0, 表示枠幅, 表示枠幅);
        output();
        pauseButton.disabled = true;
        deleteButton.disabled = true;
        counterGaugeContext.clearRect(0, 0, 表示枠幅, gaugeHeight);
        counterAnnouncer.innerText = `0 / ${timerMultiple}`;
      };

      document.onkeydown = (event) => {
        if (event.code !== 'Enter') return;
        if (document.activeElement.tagName === 'INPUT') {
          const elementId = document.activeElement.id;
          if (Object.keys(meterElements).includes(elementId)) {
            submitMeter(elementId);
          }
        } else if (!startedSwitch && !animationSwitch) {
          startExecution();
        } else {
          pause();
        }
      };

      Object.keys(meterElements).forEach((meterKey) => {
        meterElements[meterKey].meter.onpointerdown = (event) => {
          setMeterSwitch(meterKey, getClientPosition(event).X);
        };
        meterElements[meterKey].submit.onclick = () => submitMeter(meterKey);
      });

      const setTangentType = (operate) => {
        tangentType = operate;
        楕円近似弧群定義();
        output();
      };

      const documentMousemove = (event) => {
        switch (meterSwitch) {
          case 'focal-length':
            if (animationSwitch || !meterSwitch) return;
            set焦点距離(event, 'move');
            break;
          case 'color-base':
            setColorBase(event, 'move');
            break;
          case 'color-balance':
            setColorBalance(event, 'move');
            break;
          default:
            if (animationSwitch || !meterSwitch) return;
            const { X } = getClientPosition(event);
            setMeterLength(meterSwitch, X);
        }
      };

      document.onpointerup = (event) => {
        setMeterSwitch(false);
      };

      if (typeof document.ontouchmove === 'object') {
        document.ontouchmove = documentMousemove;
      } else {
        document.onmousemove = documentMousemove;
      }

      executeButton.onclick = () => {
        if (animationSwitch) return;
        startExecution();
      };

      pauseButton.onclick = () => {
        pause();
      }

      deleteButton.onclick = () => {
        deleteExecution();
      };

      焦点距離Operator.onmousedown = (event) => {
        if (animationSwitch || meterSwitch) return;
        meterSwitch = 'focal-length';
        set焦点距離(event, 'set');
      };

      colorBaseOperator.onmousedown = (event) => {
        if (meterSwitch) return;
        meterSwitch = 'color-base';
        setColorBase(event, 'set');
      };

      colorBalanceOperator.onmousedown = (event) => {
        if (meterSwitch) return;
        meterSwitch = 'color-balance';
        setColorBalance(event, 'set');
      };

      tangentTypeInputI.onchange = (event) => {
        setTangentType(event.target.checked ? 'I' : 'O');
      };

      tangentTypeInputO.onchange = (event) => {
        setTangentType(event.target.checked ? 'O' : 'I');
      };

      form.onsubmit = () => false;

      setMeterPosition('standing-circle-circumference', (静止円周 - 単位円周 / 10) / (単位円周 - 単位円周 / 10));
      setMeterPosition('回転円1', (回転円[0].周 - 単位円周 / 10) / (単位円周 - 単位円周 / 10));
      setMeterPosition('回転円2', (回転円[1].周 - 単位円周 / 10) / (単位円周 - 単位円周 / 10));
      setMeterPosition('扁平率1', 回転円[0].偏平率);
      setMeterPosition('扁平率2', 回転円[1].偏平率);
      meterElements['standing-circle-circumference'].input.value = 静止円周;
      meterElements['回転円1'].input.value = 回転円[0].周;
      meterElements['回転円2'].input.value = 回転円[1].周;
      meterElements['扁平率1'].input.value = 回転円[0].偏平率 * 100;
      meterElements['扁平率2'].input.value = 回転円[1].偏平率 * 100;
      楕円近似弧群定義();
      display焦点距離();
      initColor();
      displayColorBase();
      displayColorBalance();
      pauseButton.disabled = true;
      deleteButton.disabled = true;
      settimerMultiple();
      output();
    </script>
  </body>
</html>
